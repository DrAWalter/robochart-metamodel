import 'http://www.robocalc.circus/RoboChart' -- http://www.robocalc.circus/RoboChart
--import 'http://www.eclipse.org/emf/2002/Ecore'

package robochart

-- Robotic Platforms well-formedness conditions (RoboChart reference 3.1.1)
context RoboticPlatformDef
	-- We note that variables and operations declared directly in the platform,
	-- outside an interface, are considered as if declared in a provided
	-- interface, for the reasons already explained above. Events declared
	-- directly in the platform, on the other hand, are defined.
	def: rpProvidedVars() : Bag(Variable) =
		self.pInterfaces.variableList.vars->union(self.variableList.vars)
	def: rpProvidedOps() : Bag(OperationSig) = self.pInterfaces.operations->union(self.operations)
	def: rpDefinedEvents() : Bag(Event) = self.interfaces.events->union(self.events)
	
	-- RP1: Robotic platforms cannot require interfaces
	inv RP1: self.rInterfaces->isEmpty()
	-- RP2: Defined interfaces can only have events
	inv RP2: self.interfaces->forAll(i |
		i.variableList->isEmpty() and i.operations->isEmpty()
	)
	-- RP3: The names of variables, operations, and events are unique to the platform
	inv RP3: self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
			.variableList->union(self.variableList).vars.name
		->union(self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
			.operations->union(self.operations).name)
		->union(self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
			.events->union(self.events).name)->isUnique(i | i)
	-- RP4: Robotic platforms cannot contain clocks
	inv RP4: self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
			.clocks->isEmpty()

			
-- Interfaces well-formedness conditions (RoboChart reference 3.1.2)
context Interface
	-- I1: Provided and required interfaces contain only variables and operations
	inv I1: Context.allInstances()->collect(c | c.pInterfaces->union(c.rInterfaces))->includes(self)
		implies self.events->isEmpty()
	-- I2: Defined interfaces contain only variables and events
	inv I2: Context.allInstances().interfaces->includes(self)
		implies self.operations->isEmpty()
	-- I3: Names of variables, events and operations are unique
	inv I3: self.variableList.vars.name
		->union(self.operations->asBag().name)
		->union(self.events->asBag().name)->isUnique(i | i)

		
-- Modules well-formedness conditions (RoboChart reference 3.1.3)
context RCModule
	def: moduleControllers() : Set(Controller) =
		self.nodes->selectByKind(Controller)
	def: moduleRP() : RoboticPlatform =
		self.nodes->selectByKind(RoboticPlatform)->any(true)

	-- M1: A module must contain exactly one robotic platform, at least one controller, and not state machines
	inv M1: self.nodes->selectByKind(RoboticPlatform)->one(true)
		and self.nodes->selectByKind(Controller)->exists(true)
		and self.nodes->selectByKind(StateMachine)->isEmpty()
	-- M2: All variables and operations required by the module's controllers must be provided by the platform
	inv M2: self.nodes->selectByKind(RoboticPlatform)->exists(true) implies
		(self.moduleRP().rpDef().rpProvidedVars()
			->includesAll(self.moduleControllers().controllerDef().controllerRequiredVars())
		and self.moduleRP().rpDef().rpProvidedOps()
			->includesAll(self.moduleControllers().controllerDef().controllerRequiredOps()))
	-- M3: Each event on the robotic platform and controllers of a module must have at most one connection to or from it within the module
	inv M3: self.nodes->selectByKind(RoboticPlatform)->exists(true) implies 
		self.moduleRP().rpDef().rpDefinedEvents()
			->forAll(e | self.connections->select(c | c.efrom = e or c.eto = e)->size() <= 1)
		and self.moduleControllers().controllerDef().controllerDefinedEvents()
			->forAll(e | self.connections->select(c | c.efrom = e or c.eto = e)->size() <= 1)

			
-- Connection well-formedness conditions (RoboChart reference 3.1.4)
context Connection
	-- Cn1: Connections of a module must associate only events of the robotic platform and its controllers
	inv Cn1: RCModule.allInstances()->select(m | m.connections->includes(self))
		->forAll(m | m.nodes->includes(self.from) and m.nodes->includes(self.to))
	-- Cn2: Connections involving a robotic platform are always asynchronous
	inv Cn2: (self.from.oclIsKindOf(RoboticPlatform) or self.to.oclIsKindOf(RoboticPlatform))
		implies self.async
	-- Cn3: Connections of a controller must associate only its events and those of its state machines
	inv Cn3: ControllerDef.allInstances()->select(c | c.connections->includes(self))
		->forAll(c | c.machines->including(c)->includes(self.from)
			and c.machines->including(c)->includes(self.to)
		)
	-- Cn4: Only events of the same type may be connected
	-- NOTE: this requires and equality operator on RoboChart types
	-- Cn5: Bidirectional connections of a module may only involve events of a controller which are connected by bidirectional connections within the controller
	inv Cn5: (self.bidirec and RCModule.allInstances()->exists(m | m.connections->includes(self)))
		implies (
			(self.from.oclIsKindOf(Controller)
				implies self.from.oclAsType(Controller).controllerDef().connections
					->select(c | (c.from = self.from and c.efrom = self.efrom) 
						or (c.to = self.from and c.eto = self.efrom))
					->forAll(c | c.bidirec))
			and (self.to.oclIsKindOf(Controller)
				implies self.to.oclAsType(Controller).controllerDef().connections
					->select(c | (c.from = self.to and c.efrom = self.eto) 
						or (c.to = self.to and c.eto = self.eto))
					->forAll(c | c.bidirec))
		)
	-- Cn6: Non-bidirectional connections of a module may only connect to events of a controller which have a non-bidirectional connection from them within the controller
	inv Cn6: (not self.bidirec 
		and RCModule.allInstances()->exists(m | m.connections->includes(self))
		and self.to.oclIsKindOf(Controller)
	) implies self.to.oclAsType(Controller).controllerDef().connections
			->select(c | (c.from = self.to and c.efrom = self.eto) 
						or (c.to = self.to and c.eto = self.eto))
			->forAll(c | not c.bidirec and c.from = self.to)
	-- Cn7: Non-bidirectional connections of a module may only connect from events of a controller which have a non-bidirectional connection to them within the controller
	inv Cn7: (not self.bidirec 
		and RCModule.allInstances()->exists(m | m.connections->includes(self))
		and self.from.oclIsKindOf(Controller)
	) implies self.from.oclAsType(Controller).controllerDef().connections
			->select(c | (c.from = self.from and c.efrom = self.efrom) 
						or (c.to = self.from and c.eto = self.efrom))
			->forAll(c | not c.bidirec and c.to = self.from)
	-- Cn8: Non-bidirectional connections of a controller must not connect to events that a state machine uses as an output.
	inv Cn8: (not self.bidirec
		and ControllerDef.allInstances()->exists(c | c.connections->includes(self))
		and self.to.oclIsKindOf(StateMachine)
	) implies self.to.oclAsType(StateMachine).stmDef().ncOutputEvents()->excludes(self.eto)
	-- Cn9: Non-bidirectional connections of a controller must not connect from events that a state machine uses as an input
	inv Cn9: (not self.bidirec
		and ControllerDef.allInstances()->exists(c | c.connections->includes(self))
		and self.from.oclIsKindOf(StateMachine)
	) implies self.from.oclAsType(StateMachine).stmDef().ncInputEvents()->excludes(self.efrom)	

	
-- Controllers well-formedness conditions (RoboChart reference 3.1.5)
context ControllerDef
	-- Variables and events declared directly in the controller are considered
	-- as part of a defined interface.
	def: controllerDefinedVars() : Bag(Variable) =
		self.interfaces.variableList.vars->union(self.variableList.vars)
	def: controllerDefinedEvents() : Bag(Event) = self.interfaces.events->union(self.events)
	def: controllerRequiredVars() : Bag(Variable) = self.rInterfaces.variableList.vars
	def: controllerRequiredOps() : Bag(OperationSig) = self.rInterfaces.operations
	
	-- C1: A controller must contain at least one state machine
	inv C1: self.machines->exists(true)
	-- C2: Controllers cannot provide variables or operations to other controllers
	inv C2: self.pInterfaces->collect(i | i.variableList.vars->union(i.operations))->isEmpty()
	-- C3: All variables required by the controller's state-machines must be defined or required by the controller
	inv C3: self.controllerRequiredVars()->union(self.controllerDefinedVars())
		->includesAll(self.machines.stmDef().stmRequiredVars())
	-- C4: All operations required by the controller's state-machines must be required or defined by the controller
	inv C4: self.controllerRequiredOps()->union(self.lOperations)
		->includesAll(self.machines.stmDef().stmRequiredOps())
	-- C5: The names of variables, operations, and events are unique to the controller
	-- operations declared directly in the controller are ruled out by C7
	inv C5: self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
			.variableList->union(self.variableList).vars.name
		->union(self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
			.operations->union(self.lOperations).name)
		->union(self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
			.events->union(self.events).name)->isUnique(i | i)
	-- C6: Each event on state machines and boundary of a controller must have at most one connection to or from it within the controller
	inv C6: self.machines->forAll(m | m.stmDef().stmDefinedEvents()->forAll(e | self.connections
		->select(c | (c.from = m and c.efrom = e) or (c.to = m and c.eto = e))->size() <= 1
	)) and self.controllerDefinedEvents()->forAll(e | self.connections
		->select(c | (c.from = self and c.efrom = e) or (c.to = self and c.eto = e))->size() <= 1
	)
	-- C7: Operations must not be declared directly in a controller, but may be defined in the controller
	inv C7: self.operations->isEmpty()

	
-- State Machines well-formedness conditions (RoboChart reference 3.1.6)
context StateMachineDef
	def: stmDefinedVars() : Bag(Variable) =
		self.interfaces.variableList.vars->union(self.variableList.vars)
	def: stmDefinedEvents() : Bag(Event) = self.interfaces.events->union(self.events)
	def: stmRequiredVars() : Bag(Variable) = self.rInterfaces.variableList.vars
	def: stmRequiredOps() : Bag(OperationSig) = self.rInterfaces.operations

	-- STM1: State machines cannot have provided interfaces
	inv STM1: self.pInterfaces->isEmpty()
	-- STM2: Operations in state machines can only be required, not defined
	-- i.e. operations must not be declared directly in the state machine (defined interfaces can't have operations anyway by I2)
	inv STM2: self.operations->isEmpty()
	-- STM3: Every state machine must have exactly one initial junction
	inv STM3: self.nodes->selectByKind(Initial)->one(true)
	-- STM4: State machines must contain at least one state
	inv STM4: self.nodes->selectByKind(State)->exists(true)
	-- STM5: The names of variables, operations, and events are unique to the machine
	inv STM5: self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
			.variableList->union(self.variableList).vars.name
		->union(self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
			.operations.name)
		->union(self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
			.events->union(self.events).name)->isUnique(i | i)
	-- STM6: State machines must not have operations declared directly within them
	inv STM6: self.operations->isEmpty()

	
-- States well-formedness conditions (RoboChart reference 3.1.7)
context State
	-- S1: If a state has a non-empty set of nodes, then conditions STM3 and STM4 apply
	inv S1: self.nodes->notEmpty() implies 
		self.nodes->selectByKind(Initial)->one(true)
		and self.nodes->selectByKind(State)->exists(true)
	-- S2: A state has at most one of each type of action: entry, during, and exit
	inv S2: self.actions->selectByKind(EntryAction)->size() <= 1
		and self.actions->selectByKind(DuringAction)->size() <= 1
		and self.actions->selectByKind(ExitAction)->size() <= 1

		
-- Initial Junctions well-formedness conditions (RoboChart reference 3.1.8)
context Initial
	-- IJ1: An initial junction does not have incoming transitions
	inv IJ1: NodeContainer.allInstances()->select(nc | nc.nodes->includes(self)).transitions
		->select(t | t.target = self)->isEmpty()
	-- IJ2: An initial junction must have exactly one outgoing transition
	inv IJ2: NodeContainer.allInstances()->select(nc | nc.nodes->includes(self)).transitions
		->one(t | t.source = self)
	-- IJ3: All junction conditions apply
	-- this is implicit since Initial inherits from Junction

	
-- Junction well-formedness conditions (RoboChart reference 3.1.9)
context Junction
	-- J1: A junction must contain at least one outgoing transition
	inv J1: NodeContainer.allInstances()->select(nc | nc.nodes->includes(self)).transitions
		->exists(t | t.source = self)
	-- J2: The guards of the transitions out of a junction must form a cover
	-- NOTE: cannot be checked in general, but does not prevent generation of semantics
--	inv J2: NodeContainer.allInstances()->select(nc | nc.nodes->includes(self)).transitions
--		->select(t | t.source = self and t.condition <> null).condition
	-- J3: Transitions starting in junctions cannot have triggers
	inv J3: NodeContainer.allInstances()->select(nc | nc.nodes->includes(self)).transitions
		->select(t | t.source = self)->forAll(t | t.trigger = null)

		
-- Final states well-formedness conditions (RoboChart reference 3.1.10)
context Final
	-- FS1: Final states cannot be the source of transitions
	inv FS1: NodeContainer.allInstances()->select(nc | nc.nodes->includes(self)).transitions
		->select(t | t.source = self)->isEmpty()
	-- FS2: Final states cannot have actions
	inv FS2: self.actions->isEmpty()
	-- FS3: Final states cannot have states or transitions
	inv FS3: self.nodes->isEmpty() and self.transitions->isEmpty()

		
-- Triggers well-formedness conditions (RoboChart reference 3.1.11)
context Communication
	-- Tg1: A trigger of type SIMPLE has neither the parameter attribute not the value attribute set. This is a pure synchronisations and does not involve exchange of values
	inv Tg1: self._type = CommunicationType::SIMPLE implies (self.parameter = null and self.value = null)
	-- Tg2: A trigger of type SIMPLE must use a typeless event. This is a pure synchronisations and does not involve exchange of values
	inv Tg2: self._type = CommunicationType::SIMPLE implies (self.event <> null and self.event.type = null)
	-- Tg3: A trigger of type INPUT must have a parameter attribute and cannot have its value attribute set
	inv Tg3: self._type = CommunicationType::INPUT implies (self.parameter <> null and self.value = null)
	-- Tg4: A trigger of type OUPUT or SYNC must have a value attribute and cannot have its parameter attribute set
	inv Tg4: (self._type = CommunicationType::OUTPUT or self._type = CommunicationType::SYNC)
		implies (self.value <> null and self.parameter = null)

		
-- Transitions well-formedness conditions (RoboChart reference 3.1.12)
context Transition
	-- T1: The source and target of a transition must belong to the same container
	inv T1: NodeContainer.allInstances()
		->one(nc | nc.nodes->includes(self.source) and nc.nodes->includes(self.target))
	-- T2: If a transition has a trigger, it must be of type INPUT or SIMPLE
	inv T2: self.trigger <> null
		implies (self.trigger._type = CommunicationType::INPUT
			or self.trigger._type = CommunicationType::SIMPLE
		)

		
-- Operations well-formedness conditions (RoboChart reference 3.1.13)
context OperationDef
	-- O1: All state-machine conditions apply to operation definitions
	inv O1: 
		-- STM1: State machines cannot have provided interfaces
		self.pInterfaces->isEmpty()
		-- STM2: Operations in state machines can only be required, not defined
		-- i.e. operations must not be declared directly in the state machine (defined interfaces can't have operations anyway by I2)
		and self.operations->isEmpty()
		-- STM3: Every state machine must have exactly one initial junction
		and self.nodes->selectByKind(Initial)->one(true)
		-- STM4: State machines must contain at least one state
		and self.nodes->selectByKind(State)->exists(true)
		-- STM5: The names of variables, operations, and events are unique to the machine
		and self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
				.variableList->union(self.variableList).vars->isUnique(i | i)
			and self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
				.operations->isUnique(i | i)
			and self->collect(c | c.interfaces->union(c.rInterfaces)->union(c.pInterfaces))
				.events->union(self.events)->isUnique(i | i)
		-- STM6: State machines must not have operations declared directly within them
		and self.operations->isEmpty()

		
-- Variables well-formedness conditions (RoboChart reference 3.1.14)
--context Variable
	-- V1: If the initial value of a required variable or constant of a state machine or controller is defined, it must be consistent with the initial value of any (complementing) variable provided or required by the contexts (controllers or modules) where the state machine or controller is used
	-- NOTE: this requires expression evaluation in order to be properly defined

	
-- Expressions well-formedness conditions (RoboChart reference 3.1.15)
	-- E1: The variables declared in a set comprehension must not have initial values
context SetComp
	inv E1:	self.variables->forAll(v | v.initial = null)
	-- E2: Quantified variables in existential and universal quantifications must not have initial values
	context QuantifierExpression
	inv E2: self.variables->forAll(v | v.initial = null)
	-- E3: The variables quantified in a lambda expression must not have initial values
	context LambdaExp
	inv E3: self.variables->forAll(v | v.initial = null)


-- Timed Expressions well-formedness conditions (RoboChart reference 3.2.1)
	-- TE1: Expressions involving since(C) and sinceEntry(S) are only permitted in transition guards
		-- corresponds to CE1 and SCE1 below
	-- TE2: The clock C in an expression since(C) may only reference a clock declared within the expression's containing state-machine
		-- corresponds to CE3 below
	-- TE3: The state S in an expression sinceEntry(S) may only reference a state, and not a Final state, within the containing expression’s state-machine
		-- corresponds to SCE3 below
	-- TE4: The expressions since(C) or sinceEntry(S) may only occur in a comparison expression in which the other branch is a constant
		-- corresponds to CE2 and SCE2 below
		
-- Clock expression well-formedness conditions
context ClockExp
	-- CE1: An expression since(C) may only occur as part of a transition guard
	inv CE1: self.parentIsTransition()
	-- CE2: An expression since(C) may only occur in a branch of a comparison expression in which the other branch is an integer or float expression
	inv CE2: Expression::ComparisonExpression()->exists(comp | 
	(comp.left = self 
			and (comp.right.oclIsKindOf(IntegerExp) or comp.right.oclIsKindOf(FloatExp)))
		or (comp.right = self 
			and (comp.left.oclIsKindOf(IntegerExp) or comp.left.oclIsKindOf(FloatExp)))
	)
	-- CE3: The clock C in an expression since(C) may only reference a clock declared within the expression's containing state-machine
	inv CE3: self.parentIsTransition() implies
		self.parentTransition().containingStateMachine().clocks->includes(self.clock)

-- State Clock expression well-formedness conditions
context StateClockExp
	-- SCE1: An expression sinceEntry(S) may only occur as part of a transition guard
	inv SCE1: self.parentIsTransition()
	-- SCE2: An expression sinceEntry(S) may only occur in a branch of a comparison expression in which the other branch is an integer or float expression
	inv SCE2: ComparisonExpression()->exists(comp | 
		(comp.left = self 
			and (comp.right->oclIsKindOf(IntegerExp) or comp.right->oclIsKindOf(FloatExp)))
		or (comp.right = self 
			and (comp.left->oclIsKindOf(IntegerExp) or comp.left->oclIsKindOf(FloatExp)))
	)
	-- SCE3: The state S in an expression sinceEntry(S) may only reference a state, and not a Final state, within the containing expression’s state-machine
	inv SCE3: self.parentIsTransition() implies
		self.parentTransition().containingStateMachine().nestedStates()->includes(self.state) and not self.state.oclIsKindOf(Final)

		
-- Timed Statements well-formedness conditions (RoboChart reference 3.2.2)
context ClockReset
	-- TS1: A clock reset #C may only reference a clock declared within the action's containing state-machine, or in the case of a trigger, within the trigger's containing state-machine
	inv TS1: self.containingStateMachine().clocks->includes(self.clock)

	
-- Auxiliary definitions
	
-- function to extract RoboticPlatformDef from a RoboticPlatform (which may be a ref)
context RoboticPlatform
	def: rpDef() : RoboticPlatformDef = 
 		if self.oclIsKindOf(RoboticPlatformDef) then 
			self.oclAsType(RoboticPlatformDef)
		else 
			self.oclAsType(RoboticPlatformRef).ref
		endif
-- function to extract ControllerDef from a Controller (which may be a ref)
context Controller
	def: controllerDef() : ControllerDef = 
		if self.oclIsKindOf(ControllerDef) then 
			self.oclAsType(ControllerDef)
		else 
			self.oclAsType(ControllerRef).ref
		endif
-- function to extract StateMachineDef from a StateMachine (which may be a ref)
context StateMachine
	def: stmDef() : StateMachineDef = 
		if self.oclIsKindOf(StateMachineDef) then 
			self.oclAsType(StateMachineDef)
		else 
			self.oclAsType(StateMachineRef).ref
		endif

-- functions to get input and output events of a node container
-- (An event is considered to be an output if it is used in an OUPUT or SYNC trigger, 
-- 	or if it is used in an OUTPUT, SYNC or SIMPLE send statement.)
-- (An event is considered to be an input if it is used in an INPUT or SIMPLE trigger, 
-- 	or if it is used in an INPUT send statement.)
context NodeContainer
	def: ncInputEvents() : Bag(Event) =
		self.transitions->select(t | t.trigger <> null and 
			(t.trigger._type = CommunicationType::INPUT or t.trigger._type = CommunicationType::SIMPLE)
		).trigger.event
		->union(self.transitions->select(t | t.action <> null).action.statementInputEvents())
		->union(self.nodes->selectByKind(NodeContainer).ncInputEvents())
		->union(self.nodes->selectByKind(State).actions.action.statementInputEvents())
	def: ncOutputEvents() : Bag(Event) =
		self.transitions->select(t | t.trigger <> null and 
			(t.trigger._type = CommunicationType::OUTPUT or t.trigger._type = CommunicationType::SYNC)
		).trigger.event
		->union(self.transitions->select(t | t.action <> null).action.statementOutputEvents())
		->union(self.nodes->selectByKind(NodeContainer).ncOutputEvents())
		->union(self.nodes->selectByKind(State).actions.action.statementOutputEvents())
context Statement
	def: statementInputEvents() : Bag(Event) = Bag{}
	def: statementOutputEvents() : Bag(Event) = Bag{}
context CommunicationStmt
	def: statementInputEvents() : Bag(Event) =
		Set{self.communication}->select(t | t._type = CommunicationType::INPUT).event
	def: statementOutputEvents() : Bag(Event) =
		Set{self.communication}->select(t | Set{CommunicationType::OUTPUT, CommunicationType::SYNC, CommunicationType::SIMPLE}->includes(t._type)).event
context SeqStatement
	def: statementInputEvents() : Bag(Event) =
		self.statements.statementInputEvents()->asBag()
	def: statementOutputEvents() : Bag(Event) =
		self.statements.statementOutputEvents()->asBag()
context IfStmt
	def: statementInputEvents() : Bag(Event) =
		self._'then'.statementInputEvents()->union(self._'else'.statementInputEvents())
	def: statementOutputEvents() : Bag(Event) =
		self._'then'.statementOutputEvents()->union(self._'else'.statementOutputEvents())

-- functions on expressions to support timed expressions well-formedness conditions
context Expression
	def: parentIsTransition() : Boolean = 
		if self.oclContainer().oclIsKindOf(Expression) then
			self.oclContainer().oclAsType(Expression).parentIsTransition()
		else
			Transition.allInstances()->exists(t | t.condition = self)
		endif
	def: parentTransition() : Transition =
		if self.oclContainer().oclIsKindOf(Expression) then
			self.oclContainer().oclAsType(Expression).parentTransition()
		else
			self.oclContainer().oclAsType(Transition)
		endif

	def: ComparisonExpression() : Set(BinaryExpression) =
		BinaryExpression.allInstances()->select(x | 
			x.oclIsKindOf(Equals) or x.oclIsKindOf(Different)
			or x.oclIsKindOf(GreaterThan) or x.oclIsKindOf(LessThan) 
			or x.oclIsKindOf(GreaterOrEqual) or x.oclIsKindOf(LessOrEqual)
		)

-- function to obtain all states nested within a node container
context NodeContainer
	def: nestedStates() : Bag(State) =
		self.nodes->selectByKind(State)->union(self.nodes->selectByKind(State).nestedStates())

		-- functions to find the containing state machine for various constructs,
		-- particularly ClockReset to define the timed statement well-formedness conditions
context NodeContainer
	def: containingStateMachine() : StateMachineBody =
		if self.oclIsKindOf(StateMachineBody) then 
			self.oclAsType(StateMachineBody) 
		else 
			self.oclContainer().oclAsType(NodeContainer).containingStateMachine()
		endif
context Transition
	def: containingStateMachine() : StateMachineBody =
		self.oclContainer().oclAsType(NodeContainer).containingStateMachine()
context Action
	def: containingStateMachine() : StateMachineBody =
			self.oclContainer().oclAsType(State).containingStateMachine()
context Statement
	def: containingStateMachine() : StateMachineBody =
		if self.oclContainer().oclIsKindOf(Action) then
			self.oclContainer().oclAsType(Action).containingStateMachine()
		elseif self.oclContainer().oclIsKindOf(Transition) then
			self.oclContainer().oclAsType(Transition).containingStateMachine()
		else
			self.oclContainer().oclAsType(Statement).containingStateMachine()
		endif
context Communication
	def: containingStateMachine() : StateMachineBody =
		if self.oclContainer().oclIsKindOf(Transition) then
			self.oclContainer().oclAsType(Transition).containingStateMachine()
		else
			self.oclContainer().oclAsType(Statement).containingStateMachine()
		endif
context ClockReset
	def: containingStateMachine() : StateMachineBody =
		if self.oclContainer().oclIsKindOf(Action) then
			self.oclContainer().oclAsType(Action).containingStateMachine()
		elseif self.oclContainer().oclIsKindOf(Communication) then
			self.oclContainer().oclAsType(Communication).containingStateMachine()
		else
			self.oclContainer().oclAsType(Statement).containingStateMachine()
		endif
		
endpackage